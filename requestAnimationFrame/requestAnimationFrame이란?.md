# window.requestAnimationFrame

`window.requestAnimationFrame()`은 브라우저에게 수행하기를 원하는 애니메이션을 알리고 다음 리페인트가 진행되기 전에 해당 애니메이션을 업데이트하는 함수를 호출하게 한다. 이 메서드는 리페인트 이전에 실행 할 콜백을 인자로 받는다.

> 다음 리페인트에서 그 다음 프레임을 애니메이트 하려면 콜백 루틴이 반드시 스스로 `requestAnimationFrame()`을 호출해야 한다. 즉, 재귀호출을 해줘야 한다는것이다. 이유는 `requestAnimationFrame()`은 setTimeout이나 setInterval에 등록된 콜백함수처럼 이벤트루프가 콜스택이 비었을때 호출해주는것이 아닌 브라우저가 호출 시기를 결정하기 때문이다. 

화면에 새로운 애니메이션을 업데이트 할 준비가 될 때마다 이 메서드를 호출하는것이 좋다. 이는 브라우저가 다음 리페인트를 수행하기 전에 호출된 애니메이션 함수를 요청한다. 콜백의 수는 보통 1초에 60회이지만 일반적으로 대부분의 브라우저에서는 W3C의 권장사항에 따라 그 수가 디스플레이 주사율과 일치하게 된다.(집에 여러개의 주사율은 가진 모니터가 있는데 테스트해보니 크롬 브루우저 기준 모두 다 다르게 동작했다.) 대부분의 모던한 브라우저에서는 성능과 배터리 수명 향상을 위해 `requestAnimationFrame()` 호출은 백그라운드 탭이나 hidden `<iframe>`에서 실행이 중단된다. (실제로 크롬 브라우저를 백그라운드에 뒀더니 콜백함수가 호출되지 않고 있었다.)

콜백 메서드에는 `requestAnimationFrame()`이 대기된 콜백을 실행하는 시점을 나타내는 단일 인자 `DOMHighResTimeStamp`가 전달된다. 따라서 모든 이전 콜백의 작업 부하를 계산하는 시간이 지나갔음에도 불구하고 단일 프레임에서의 다중 콜백은 각각 동일한 타임스탬프를 받는다. 이 타임스탬프는 밀리초 단위의 십진수지만 최소 정밀도는 1ms이다. (브라우저 별로 5us ~ 1ms로 나뉘지만 최소가 1ms라는 말)

requestAnimationFrame의 콜백 내에서 DOM 작업을 수행하면 더 효율적이다. 왜냐면 메인 스레드를 차단하지 않으며 다음 repaint가 이벤트 루프에서 스케줄링 되기 직전에 실행된다.